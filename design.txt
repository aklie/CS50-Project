

	Before we began implementing our code, we laid out the features most wanted to have in our project. Above all, we wanted a chrome extension that would
be capable of drawing on webpages. Besides that, we also wanted features including customizability of the drawing color and thickness, the ability to highlight documents, the ability to save screenshots of webpages, the ability to add text to webpages and the ability to revert all changes. Finally, we wanted the interface to be attractive and easy to use. The way we approached tackling the project followed a similar priority of steps. Since creating a draw function was most important to us, we completed that first. Then, we added features based on feasibility and benefit to our project. Finally, we improved the aesthetics and layout of the front end. 
	To create a working draw function, we had to do a great deal of research on Chrome extensions, HTML and Javascript. We thoroughly read over the
Chrome extension developer's guide, which taught us the basics of making a chrome extension. From here, we gathered how to use manifest.json, jquery, content and background page and more. We also looked at the Chrome extension code of many different extensions for inspiration. Reading through code taught us that we needed to use the HTML canvas element and CanvasRenderingContext2D interface in order to mark on webpages. This led us to peruse through the Canvas API for help in making the code. 
	When we approached completing our secondary functions, we first implemented the easier ones. Customizing drawing color and line thickness were a
matter of a little googling and a few lines of HTML on our options.html and options.jquery page, as well as looking at the Chrome extension developer's guide and other chrome extensions for help on syncing information to the Chrome browser to allow for changes to default settings. We decided to place these customizability features on the options page instead of on the draggable options element because we wanted a minimalist, uncluttered look to the extension. 
	Reverting changes also was not too difficult, but absolutely essential for our final product. We had seen chrome extensions without revert functions
that were terribly hard to use, so we knew we had to add some to our extension. We had an eraser function, which is basically just the 
drawing function with slight changes mainly in globalCompositeOperation. We also had a 'clear' function, which also was a very simple one line command to clear the canvas. Exiting the program involved removing eventlisteners, the canvas and the draggable element.
	The ability to highlight documents was a little more difficult. First, the highlighted line needed to be translucent to allow readability of the
words highlighted. This was done with a single line of code that we found through googling; after much experimentation, we decided on .35 transparency. Second, we wanted the highlight to be a straight line instead of a drawn line, for the user's convenience. This part was more difficult, as the highlight draw was different than the normal draw in that a normal draw continually draws upon movement of cursor, whereas the highlight should only be drawn onto canvas once mouseclick is released (in other words, X & Y prev should not be updated as it is in the draw function). Here, we modified the draw function and the findxy functions with a boolean for highlight to only show a highlight line once mouseclick was released.
	Saving screenshots was also more difficult to implement. We had to research different methods of taking pictures of the page. Early on, we found an 
easy two-line solution to take a screenshot. Unfortunately, this solution would only take a picture of the canvas and not the webpage, so it was not acceptable for our final product. More research, including some sample files provided by the Chrome extension developer's guide, led us to chrome.tabs.captureVisibleTab, which takes a screenshot of the open tab. However, chrome.tabs.captureVisibleTab had many issues because it can only be run in a background or event file and not a content file. This meant we had to create a message sender and send a message from the content file to the background file before running the function. Finally, we got the function to work, which was very good because without the function, there was no way to save the web doodle as a image file without using keyboard shortcuts to take a screenshot.
	Our group collectively made the decision not to add the ability to add text to webpages. Research online led us to conclude that incorporating text 
editing was beyond the scope of our limited time frame and abilities. There were too many moving parts, packages and other complexities to deal with and we would rather improve our other functions and the aesthetics of our interface. Moreoever, users can already write on the page using the draw function, so adding text was not entirely necessary.
	The final step was improving the aesthetics of the extension. We put a lot of time into making editing the HTML and Javascript to makethe front end 
look professional. In general, our approach was a more minimalist style avoiding clutter at all costs. We prefered usability and attractiveness over an excess of functions. 
